module init

implicit none

integer, parameter :: pl = 8 ! задает точность real(pl)

integer :: N ! число ячеек по одному измерению (у нас квадрат NxN)
integer :: Ncenter ! сторона внутреннего горячего квадрата (по условию)
integer :: maxTimelvl ! наибольший интересуемый номер уровня по времени

! Следующие массивы задают значения разных величин на сетке. Примечание:

! Третье измерение добавлено в массивы для того, чтобы иметь еще три слоя.
! Первый из четырех слоев -- это значения в центрах ячеек
! Второй из четырех слоев -- это значения в центре верхней грани ячейки
! (это эквивалентно сдвигу сетки вверх по координате i на полшага)
! Третий из четырех слоев -- это значения в центре правой грани ячейки
! (это эквивалентно сдвигу сетки вправо по координате j на полшага)
! Четвертый из четырех слоев -- это значения в правом верхнем углу ячейки
! (это эквивалентно сдвигу сетки вверх и вправо на полшага по обеим
! координатам i и j

! Так как границ у ячеек на одну больше, чем число ячеек,
! была выбрана сетка второго слоя так, чтобы индексы (i,j) массива в фортране
! на самом деле соответствовали (i+1/2,j+1/2).
! Прим.: например, (i+1,j-1) соотв. (i+3/2,j-1/2) реальной сетки. 
! Таким образом, сетка слоев сдвинута относительно первого слоя на 
! +1/2 шага по X и на +1/2 шага по Y.
! Так как существуют {i,j}-1/2, то нужно записать еще точки слева и снизу от 
! (i=1,j=1), поэтому добавлен индекс "0" для второго слоя
! Заполнены значениями будут элементы массивов с индексами 
! (1:N,1:N,1) -- первый слой, и с (0:N,1:N,2) -- второй слой,
! (1:N,0:N,3) -- третий слой, (0:N,0:N,4) -- четвертый слой

! Левый нижний угол поля соотв. координате (0,0), правый верхний -- (N,N)

real(pl), dimension(:,:,:), allocatable :: Rho, Pr ! плотн. и давление на сетке
real(pl), dimension(:,:,:), allocatable :: U, V, W ! компоненты скор. и энергия

real(pl) :: tau, h ! шаг по времени и по координате



contains

subroutine init_const()
	! Просто инициализация всех переменных, что у меня есть
	implicit none

	!--------------------------------------------
	N = 400
	allocate(Rho(0:N,0:N,1:4), Pr(0:N,0:N,1:4))
	allocate(U(0:N,0:N,1:4), V(0:N,0:N,1:4), W(0:N,0:N,1:4))

	! Произвольно взято Ncenter = доля (1/10) от стороны большого квадрата:
	Ncenter = N / 10 

	tau = 0.1_pl
	h = 100._pl / N
	maxTimelvl = 10

end subroutine init_const


subroutine init_values()
	! Присвоение функциям плотности, скорости и т.д. начальных значений,
	! которые соответствуют нулевому уровню по времени, когда
	! газ еще был неподвижен (до того, как система была "отпущена")
	implicit none

	integer :: i, j

	! mask -- массив-маска, который понадобится для присвоения
	! массиву энергий начальных значений. Его форма совпадает с формой W.
	! Он выделен отдельно в этой процедуре для возможности менять форму
	! центрального горячего объекта, проводя операции только с ним,
	! чтобы не заморачиваться в forall со слоями и центрами/границами ячеек
	logical, dimension(:,:,:), allocatable :: mask 

	!--------------------------------------------
	Rho = 1 ! произвольно заданное начальное значение плотности = 1
	V = 0 ! начальные значения скорости нулевые, потому что предполагается,
	U = 0 ! что газ был неподвижен, его "отпустили" в момент времени t=0

	!--------------------------------------------
	allocate(mask(0:N,0:N,1:4))
	! Начальная энергия по условию не является одинаковой всюду.
	! Есть большой квадрат NxN, и внутри него в центре маленький
	! квадрат Ncenter x Ncenter, у которого температура сильно больше.
	! Температура фигурирует только в выражении для внутренней энергии
	! газа, и используется только энергия (а не температура напрямую).

	! Поэтому можно присвоить начальные значения сразу для энергии.
	! Задавать их буду так: Энергия всюду, кроме маленького квадрата в центре
	! равна 1, а в центральном квадрате равна 50. 
	! Следующий блок присваивает значения энергии, используя массив-маску,
	! равный .FALSE. всюду, кроме центрального малого квадрата:

	! Только первый слой (границы малого квадрата будут иметь значения
	! .FALSE., а центральные части граничных ячеек -- .TRUE.):
	forall (i = -Ncenter/2 : Ncenter/2, j = -Ncenter/2 : Ncenter/2)
		mask(N/2+i,N/2+j,1) = .TRUE.
	end forall

	! Непосредственно присвоение значений:
	where (mask)
		W = 50
	else where 
		W = 1
	end where

	!--------------------------------------------

	Pr = 0 ! Давление будет посчитано в цикле k=1,maxTimelvl в main.f95


end subroutine init_values

end module init